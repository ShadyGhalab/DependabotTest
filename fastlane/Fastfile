require 'uri'
require 'net/http'

default_platform(:ios)

setup_ci

default_xcode = "Xcode_16.1"
default_simulator = "iPhone 15,OS=18.1"
build_directory = "./fastlane/build"

platform :ios do
  desc "Trigger the `beta` lane with the specific tag"
  lane :trigger_beta_with_tag do |options|
    (version, build) = get_version_and_build(tag: options[:tag])
    beta(version: version, build: build)
  end

  desc "Trigger the `beta_firebase` lane with the specific tag"
  lane :trigger_beta_firebase_with_tag do |options|
    (version, build) = get_version_and_build(tag: options[:tag])

    # Lightweight tags, like those used by the Games team, will have an empty contents and no tagger information.
    tag_contents = sh("git for-each-ref --format='%(contents)' refs/tags/#{options[:tag]}").strip
    tag_tagger = sh("git for-each-ref --format='%(taggername) %(taggeremail)' refs/tags/#{options[:tag]}").strip

    message = ""

    unless tag_contents.nil? || tag_contents.empty?
      message += tag_contents.split("\n-----BEGIN PGP SIGNATURE-----", 2)[0]
    else
      message += "Please check the release notes in Jira"
    end

    unless tag_tagger.nil? || tag_tagger.empty?
      message += "\n"
      message += "Created by: " + tag_tagger
    end

    beta_firebase(version: version, build: build, message: message, xcode: options[:xcode])
  end

  desc "Build and upload a new beta build to TestFlight. When running without an API key pass `skip_api_key:true` to fallback to the username and password authentication."
  lane :beta do |options|
    (version, build) = [options[:version], options[:build]]
    unless version && version.match(/^[0-9]+.[0-9]+.[0-9]+$/) && build && build.match(/^[0-9]+$/)
      UI.user_error!("Should input the version and build correctly, e.g., 'beta version:1.2.3 build:123'")
    end

    release(version: version, build: build, configuration: "Release", test_group: ["SportyBetTesters", "IN Team", "Pleased Team"])
  end


  desc "Build beta build"
  lane :beta_build do |options|
    (version, build) = [options[:version], options[:build]]

    xcode = options[:xcode] || default_xcode
    xcode_select("/Applications/#{xcode}.app")

    unless version
      UI.user_error!("`version` parameter is required")
    end

    unless build
      UI.user_error!("`build` parameter is required")
    end

    setup_app_store_connect_api_key

    # Temporary to allow for builds to be created while "a required agreement is missing or has expired"
    match(
      readonly: true,
      type: "adhoc",
      # force_for_new_devices: true
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      team_id: ENV["sigh_com.sportybet.SportyBet_adhoc_team-id"],
      code_sign_identity: "iPhone Distribution",
      profile_name: ENV["sigh_com.sportybet.SportyBet_adhoc_profile-name"],
      targets: "SportyBet",
      build_configurations: "Release"
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      team_id: ENV["sigh_com.sportybet.SportyBet.Widgets_adhoc_team-id"],
      code_sign_identity: "iPhone Distribution",
      profile_name: ENV["sigh_com.sportybet.SportyBet.Widgets_adhoc_profile-name"],
      targets: "WidgetsExtension",
      build_configurations: "Release"
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      team_id: ENV["sigh_com.sportybet.SportyBet.Intents_adhoc_team-id"],
      code_sign_identity: "iPhone Distribution",
      profile_name: ENV["sigh_com.sportybet.SportyBet.Intents_adhoc_profile-name"],
      targets: "Sporty Intents",
      build_configurations: "Release"
    )

    increment_build_number(build_number: build, xcodeproj: "SportyBet.xcodeproj")
    increment_version_number(version_number: version, xcodeproj: "SportyBet.xcodeproj")

    start_message = "🔨 Start building `SportyBet` with ad-hoc, version `#{version}` (`#{build}`) 🛠"
    # send_plain_message_to_slack(message: start_message)
    UI.message start_message

    build_app(
      scheme: "SportyBet",
      export_method: "ad-hoc",
      output_directory: build_directory,
      buildlog_path: build_directory,
      xcargs: "-skipPackagePluginValidation",
      derived_data_path: "~/Library/Developer/Xcode/#{xcode}_DerivedData",
      archive_path: "#{build_directory}/SportyBet.xcarchive",
    )
  end

  desc "Build and upload a new beta build to Firebase."
  lane :beta_firebase do |options|
    (version, build, message) = [options[:version], options[:build], options[:message]]

    xcode = options[:xcode] || default_xcode
    xcode_select("/Applications/#{xcode}.app")

    unless version
      UI.user_error!("`version` parameter is required")
    end

    unless build
      UI.user_error!("`build` parameter is required")
    end

    firebase_token = ENV["FIREBASE_TOKEN"]

    unless firebase_token
      UI.user_error!("FIREBASE_TOKEN environment variable must be set to upload to Firebase")
    end

    beta_build(version: version, build: build, xcode: xcode)

    # detect if version start with "9", if do, include IN team to testers
    if version.match(/^9/)
      firebase_app_distribution(
        firebase_cli_token: firebase_token,
        groups: "internal, ued, in-team",
        release_notes: message
      )
    else
      firebase_app_distribution(
        firebase_cli_token: firebase_token,
        groups: "internal, ued",
        release_notes: message
      )
    end

    ["GoogleService-Info", "GoogleService-Info_TestFlight"].each { |plist|
      upload_symbols_to_crashlytics(
        gsp_path: "./SportyBet/#{plist}.plist",
        debug: true
      )
    }

    slack_json = generate_success_message(version: version, build: build, configuration: "Firebase")
    send_message_to_slack_using_json(json: slack_json)
  end

  desc "Build SportyBet with SportyGames to TestFlight."
  lane :sporty_games_integration do |options|
    build = options[:build]
    release(version: "9.9.9", build: build, configuration: "AppStoreDev", test_group: ["SportyBetTesters"], xcode: options[:xcode])
  end

  desc "Build and upload new build to TestFlight. When running without an API key pass `skip_api_key:true` to fallback to the username and password authentication."
  lane :release do |options|
    (version, build, configuration, test_group) = [options[:version], options[:build], options[:configuration], options[:test_group]]

    xcode = options[:xcode] || default_xcode
    xcode_select("/Applications/#{xcode}.app")

    unless version && build
      UI.user_error!("Missing input 'version', 'build'")
    end

    unless options[:skip_api_key]
      setup_app_store_connect_api_key
    end

    increment_build_number(build_number: build, xcodeproj: "SportyBet.xcodeproj")
    increment_version_number(version_number: version, xcodeproj: "SportyBet.xcodeproj")
    start_message = "🔨 Start building `SportyBet` configuration: `#{configuration}` version: `#{version}` build: `#{build}` 🛠"
    send_plain_message_to_slack(message: start_message)
    UI.message start_message

    # This used to only pull the certificates for `app_identifier` but that means we don't get the certificates
    # for extensions, e.g. widgets. It's probably not needed for `upload_to_testflight` either but it's being
    # kept this way to make this change as minimal as possible.
    match(type: "appstore")

    build_app(
      scheme: "SportyBet",
      export_method: "app-store",
      output_directory: build_directory,
      configuration: configuration,
      buildlog_path: build_directory,
      xcargs: "-skipPackagePluginValidation",
      suppress_xcode_output: false,
      derived_data_path: "~/Library/Developer/Xcode/#{xcode}_DerivedData",
    )

    app_identifier = ""
    case configuration
    when "Release"
      app_identifier = "com.sportybet.SportyBet"
    when "AppStoreDev"
      app_identifier = "com.sportybet.SportyBet.dev"
    else
      UI.user_error!("Got an unknown configuration `#{configuration}`")
    end

    begin
      upload_to_testflight(
        app_identifier: app_identifier,
        distribute_external: true,
        beta_app_review_info: {
          contact_email: "hill.hung@opennet.tw",
          contact_first_name: "Hill",
          contact_last_name: "Hung",
          contact_phone: "+886921075338",
          demo_account_name: "9091082066",
          demo_account_password: "test1234ng"
        },
        beta_app_feedback_email: "hill.hung@opennet.tw",
        demo_account_required: true,
        localized_build_info: {
          "default": {
            whats_new: "Please check the release notes in Jira",
          }
        },
        groups: test_group
      )
    rescue Exception => e
      if e.message.include? "Another build is in review"
        UI.message "Another build is in review. Skip and go to next step."
      else
        raise
      end
    end

    plists = [""]
    case configuration
    when "Release"
      plists = ["GoogleService-Info", "GoogleService-Info_TestFlight"]
    when "AppStoreDev"
      plists = ["GoogleService-Info_SportyBetDev"]
    else
      UI.user_error!("Got an unknown configuration `#{configuration}`")
    end
    download_dsyms(app_identifier: app_identifier, version: version, build_number: build)
    plists.each { |plist|
      upload_symbols_to_crashlytics(
        gsp_path: "./SportyBet/#{plist}.plist",
        debug: true
      )
    }

    slack_json = generate_success_message(version: version, build: build, configuration: configuration)
    send_message_to_slack_using_json(json: slack_json)
  end

  desc "Download iOS certificates (read only)"
  lane :download_certs do |options|
    unless options[:skip_api_key]
      setup_app_store_connect_api_key
    end
    match
  end

  desc "Force recreation of iOS certificates"
  lane :renew_cert_and_all_profiles do |options|
    unless options[:skip_api_key]
      setup_app_store_connect_api_key
    end
    match_nuke(
      readonly: false,
      skip_confirmation: true
      )
    match(
      readonly: false,
      force: true,
    )
    match(
      readonly: false,
      force: true,
      type: "adhoc"
    )
  end

  desc "Sync the dSYM to Firebase with the specific tag, e.g. beta/1.4.0/1"
  lane :sync_dsym do |options|
    (version, build) = get_version_and_build(tag: options[:tag])

    download_dsyms(version: version, build_number: build)
    ["GoogleService-Info", "GoogleService-Info_TestFlight"].each { |plist|
      upload_symbols_to_crashlytics(
        gsp_path: "./SportyBet/#{plist}.plist",
        debug: true
      )
    }
    clean_build_artifacts
  end

  desc "Register for new devices"
  lane :register_new_device do |options|
    setup_app_store_connect_api_key
    register_devices(
      devices: { options[:name] => options[:id] }
    )
    match(
      readonly: false,
      type: "adhoc",
      force_for_new_devices: true
    )
  end

  desc "Perform UI Tests"
  lane :run_ui_tests do |options|
    # input
    only_tests = options[:only_tests] || []
    simulator = options[:simulator] || default_simulator
    xcode = options[:xcode] || default_xcode

    #xcodebuild parameters
    project = "../SportyBet.xcodeproj"
    scheme = "SportyBetUITests"
    test_result_path = "./build/SportyBetUITests.xcresult"
    build_log_path = "./build/SportyBetUITests.log"
    derived_data_path = "~/Library/Developer/Xcode/#{xcode}_DerivedData"

    # clear files in build directory if exist or create one
    if Dir.exist?("./build")
      sh("rm -rf ./build/*")
    else
      FileUtils.mkdir_p("./build")
    end

    beautifier = ""

    `command -v xcbeautify`
    if $?.success?
      beautifier = " | xcbeautify"

      if ENV["GITHUB_ACTIONS"]
        beautifier += " --renderer github-actions"
      end
    end

    # switch running xcode
    xcode_select("/Applications/#{xcode}.app")

    begin
      only_tests_option = only_tests.empty? ? '' : " #{only_tests}"
      sh("set -o pipefail && env NSUnbufferedIO=YES xcodebuild -scheme #{scheme} -project #{project} -derivedDataPath #{derived_data_path} -destination 'platform=iOS Simulator,name=#{simulator}' -resultBundlePath #{test_result_path} -testPlan 'SportyBetUITests' -skipPackagePluginValidation -retry-tests-on-failure#{only_tests_option} test#{beautifier} | tee #{build_log_path}")
      if Dir.exist?(test_result_path)
        #https://github.com/fastlane/fastlane/issues/20809#issuecomment-1924188122
        trainer(path: build_directory, output_directory: build_directory, fail_build: false)
      end
    rescue => ex
      if Dir.exist?(test_result_path)
        #https://github.com/fastlane/fastlane/issues/20809#issuecomment-1924188122
        trainer(path: build_directory, output_directory: build_directory, fail_build: false)
      end
      UI.user_error!("UI Tests failure, plz check log at directory #{build_directory}")
    end
  end

  desc "Perform Unit Tests"
  lane :run_unit_tests do |options|
    # input
    simulator = options[:simulator] || default_simulator
    xcode = options[:xcode] || default_xcode

    #xcodebuild parameters
    project = "../SportyBet.xcodeproj"
    scheme = 'All\ Tests'
    test_result_path = "./build/SportyBetUnitTests.xcresult"
    build_log_path = "./build/SportyBetUnitTests.log"
    derived_data_path = "~/Library/Developer/Xcode/#{xcode}_DerivedData"

    # clear files in build directory if exist or create one
    if Dir.exist?("./build")
      sh("rm -rf ./build/*")
    else
      FileUtils.mkdir_p("./build")
    end

    beautifier = ""

    `command -v xcbeautify`
    if $?.success?
      beautifier = " | xcbeautify"

      if ENV["GITHUB_ACTIONS"]
        beautifier += " --renderer github-actions"
      end
    end

    # switch running xcode
    xcode_select("/Applications/#{xcode}.app")

    begin
      sh("set -o pipefail && env NSUnbufferedIO=YES xcodebuild -scheme #{scheme} -project #{project} -derivedDataPath #{derived_data_path} -destination 'platform=iOS Simulator,name=#{simulator}' -resultBundlePath #{test_result_path} -skipPackagePluginValidation test#{beautifier} | tee #{build_log_path}")
    rescue => ex
      if Dir.exist?(test_result_path)
        trainer(path: build_directory, output_directory: build_directory, fail_build: false)
      end
      UI.user_error!("Unit Tests failure, plz check log at directory #{build_directory}")
    end
  end
  
  desc "Perform Snapshot Tests"
  lane :run_snapshot_tests do |options|
    # input
    simulator = options[:simulator] || default_simulator
    xcode = options[:xcode] || default_xcode

    #xcodebuild parameters
    project = "../SportyBet.xcodeproj"
    scheme = 'SportyBetSnapshotTests'
    test_result_path = "./build/SportyBetSnapshotTests.xcresult"
    build_log_path = "./build/SportyBetSnapshotTests.log"
    derived_data_path = "~/Library/Developer/Xcode/#{xcode}_DerivedData"

    # clear files in build directory if exist or create one
    if Dir.exist?("./build")
      sh("rm -rf ./build/*")
    else
      FileUtils.mkdir_p("./build")
    end

    beautifier = ""

    `command -v xcbeautify`
    if $?.success?
      beautifier = " | xcbeautify"

      if ENV["GITHUB_ACTIONS"]
        beautifier += " --renderer github-actions"
      end
    end

    # switch running xcode
    xcode_select("/Applications/#{xcode}.app")

    begin
      sh("set -o pipefail && env NSUnbufferedIO=YES xcodebuild -scheme #{scheme} -project #{project} -derivedDataPath #{derived_data_path} -destination 'platform=iOS Simulator,name=#{simulator}' -resultBundlePath #{test_result_path} -skipPackagePluginValidation test#{beautifier} | tee #{build_log_path}")
    rescue => ex
      if Dir.exist?(test_result_path)
        trainer(path: build_directory, output_directory: build_directory, fail_build: false)
      end
      UI.user_error!("Snapshot Tests failure, plz check log at directory #{build_directory}")
    end
  end

  desc "Split the tag to the version and build"
  private_lane :get_version_and_build do |options|
    tag = options[:tag]

    unless tag
      UI.user_error!("You are supposed to input the tag.")
    end

    tag = options[:tag]

    if tag.start_with?("firebase")
      # The tag format should be 'firebase/{version}/{build}' for SportyBet builds, e.g. 'firebase/1.0.0/ABC-123-0'
      unless tag.match(/^firebase\/[0-9]+.[0-9]+.[0-9]+\/[A-Z]+-[0-9]+-[0-9]+$/)
        # The Games team has a different format, which is triggered directly (no tag should be created)
        unless tag.match(/^firebase\/9.9.9\/[0-9]+$/)
          UI.error "Got the invalid tag: '#{tag}'"
          UI.user_error!("Invalid format of tag")
        end
      end
    elsif tag.start_with?("beta")
      # The tag format should be "beta/{version}/{build}", e.g. "beta/1.0.0/1"
      unless tag.match(/^beta\/[0-9]+.[0-9]+.[0-9]+\/[0-9]+$/)
        UI.error "Got the invalid tag: '#{tag}'"
        UI.user_error!("Invalid format of tag")
      end
    else
      UI.error "Got the invalid tag: '#{tag}'"
      UI.user_error!("Invalid format of tag")
    end

    tag_components = tag.split("/")
    [tag_components[1], tag_components[2]]
  end

  desc "Send the plain message to the Slack default group"
  private_lane :send_plain_message_to_slack do |options|
    message = options[:message]
    unless message
      UI.message "Skip sending the message to Slack. ✉️"
    else
      json = { "text" => message }.to_json
      send_message_to_slack_using_json(json: json)
    end
  end

  desc "Send the message with JSON format to the Slack default group"
  private_lane :send_message_to_slack_using_json do |options|
    body_json = options[:json]
    slack_url = ENV["SLACK_API_URL"]

    unless body_json && slack_url && is_ci
      UI.message "Skip sending the message to Slack. ✉️"
    else
      uri = URI.parse(slack_url)

      response = Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.scheme == 'https') do |http|
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request.body = body_json
        http.request request
      end

      case response
      when Net::HTTPSuccess, Net::HTTPRedirection
        UI.message "The message has been sended to Slack."
      else
        UI.error "Send message failed. Response: #{response.value}"
      end
    end
  end

  desc "Sould pass version and build"
  private_lane :generate_success_message do |options|
    (version, build, configuration) = [options[:version], options[:build], options[:configuration]]

    workflow_url = ""
    release_method = ""
    xcode_configuation =""
    case configuration
    when "Release"
      workflow_url = "https://github.com/opennetltd/sportybet-ios/actions/workflows/beta.yml"
      release_method = "TestFlight"
      xcode_configuation = configuration
    when "AppStoreDev"
      workflow_url = "https://github.com/opennetltd/sportybet-ios/actions/workflows/integrate_sporty_games.yml"
      release_method = "TestFlight"
      xcode_configuation = configuration
    when "Firebase"
      workflow_url = "https://github.com/opennetltd/sportybet-ios/actions/workflows/beta_firebase.yml"
      release_method = "Firebase"
      xcode_configuation = "Release"
    else
      UI.user_error!("Got an unknown configuration `#{configuration}`")
    end

    if version && build
      git_hash = commit = `git rev-parse --short HEAD`.chomp
      current_time_stamp = Time.now.to_i
      %Q{
        {
          "text": "🎊 Builds and uploads to #{release_method} *successfully* 🎊",
          "attachments": [
              {
                "color": "#36a64f",
                "title": ":sportybet_app: SportyBet iOS",
                "fields": [
                  {
                      "title": "Version",
                      "value": "#{version}",
                      "short": true
                  },
                  {
                      "title": "Build",
                      "value": "#{build}",
                      "short": true
                  },
                  {
                    "title": "Git Commit Hash",
                    "value": "#{git_hash}",
                    "short": true
                  },
                  {
                    "title": "Xcode Configuration",
                    "value": "#{configuration}",
                    "short": true
                  },
                  {
                    "title": "GitHub Action",
                    "value": "#{workflow_url}",
                    "short": false
                  }
                ],
                "ts": #{current_time_stamp}
              }
          ]
        }
      }
    end
  end

  desc "Build Simulator and check .app file"
  lane :build_simulator do |options|
    # input
    simulator = options[:simulator] || default_simulator
    xcode = options[:xcode] || default_xcode
    version = options[:version]
    build = options[:build]

    # xcodebuild parameters
    project = "../SportyBet.xcodeproj"
    scheme = "SportyBet"
    derived_data_path = "~/Library/Developer/Xcode/#{xcode}_DerivedData"
    build_log_path = "./build/SportyBetBuild.log"
    app_path = "#{derived_data_path}/Build/Products/Debug-iphonesimulator/SportyBet.app"
    destination_app_path = "./build/SportyBet.app"
    zip_path = "./build/SportyBet.app.zip"

    # increment_build_and_version_number
    increment_build_number(build_number: build, xcodeproj: "SportyBet.xcodeproj")
    increment_version_number(version_number: version, xcodeproj: "SportyBet.xcodeproj")

    # clear files in build directory if exist or create one
    if Dir.exist?("./build")
      sh("rm -rf ./build/*")
    else
      FileUtils.mkdir_p("./build")
    end

    # switch running xcode
    xcode_select("/Applications/#{xcode}.app")

    begin
      sh("set -o pipefail && env NSUnbufferedIO=YES xcodebuild -scheme #{scheme} -project #{project} -derivedDataPath #{derived_data_path} -destination 'platform=iOS Simulator,name=#{simulator}' -skipPackagePluginValidation build | tee #{build_log_path}")

      # Check if .app file exists
      if File.exist?(File.expand_path(app_path))
        UI.message("Build succeeded and .app file is located at: #{app_path}")

        FileUtils.mv(File.expand_path(app_path), File.expand_path(destination_app_path))
        sh("cd #{File.dirname(destination_app_path)} && zip -r #{File.expand_path(zip_path)} #{File.basename(destination_app_path)}")

      else
        UI.user_error!("Build succeeded but .app file not found in: #{app_path}")
      end
    rescue => ex
      UI.user_error!("Build failure #{ex}, please check log at #{build_log_path}")
    end
  end

  lane :auto_release do
    require 'spaceship'

    setup_app_store_connect_api_key

    bundle_id = "com.sportybet.SportyBet"

    app = Spaceship::ConnectAPI::App.find(bundle_id)

    UI.message("🔍 Checking for approved versions ready to release for #{bundle_id}...")

    approved_version = app.get_pending_release_app_store_version

    if approved_version
      version_string = approved_version.version_string
      UI.message("📦 Releasing version #{version_string}...")
      begin
        approved_version.create_app_store_version_release_request
        UI.success("✅ Successfully triggered release of version #{version_string}!")
      rescue => e
        UI.error("🚨 Failed to trigger release: #{e.message}")
        raise
      end
    else
      UI.important("❌ No approved version pending release for #{bundle_id}.")
    end
  end

  private_lane :setup_app_store_connect_api_key do
    # Relies on environment variables to setup to allow for both local and CI use.
    # See `fastlane action app_store_connect_api_key` for expected environment variable names.
    app_store_connect_api_key()
  end

  error do |lane, exception, options|
    command = %{error_message=$(cat << EOF
#{exception}
EOF)
error_message="${error_message//'%'/'%25'}"
error_message="${error_message//$'\n'/'%0A'}"
error_message="${error_message//$'\r'/'%0D'}"
echo "::set-output name=fastlane_error_message::$error_message"}
    system(command)
    send_plain_message_to_slack(message: "❌ Fail to execute Fastlane [#{lane}] ❌\n#{exception}\n✉️ [Github Action]: https://github.com/opennetltd/sportybet-ios/actions")
  end
end
